""" 3. classmethod и staticmethod """

"""Алгоритм выбора типа метода

1.Определите, для каких целей будет написан метод: будут использоваться свойства объекта, или будут использоваться 
свойства класса, или функционал метода только логически относится к данному классу, но не задействует ни объект,
 ни класс.

2.В случае если будут использоваться свойства объекта, реализуйте обычный метод.

3.Если будут использоваться свойства класса (например, атрибут на уровне класса), реализуйте класс-метод.

4.Если функционал метода только логически относится к данному классу, но не задействует ни объект, ни класс,
 то можно создавать статик-метод.
"""




""" Задача
1. Добавить  класс-метод from_string  для изменения атрибутов Имя, Фамилия из полного имени
2. Добавить класс-метод set_raise_amt для изменения атрибутов класса, хранящего уровень индексации ЗП.
3. Добавить статистический метод is_workday для определения рабочего дня.
"""

import datetime


class Employee:
    raise_amt = 1.04

    def __init__(self, first, last, pay):
        # __init__ - создан для заполнения(инициализирования) атрибутов при создании нового объекта
        self.first = first
        self.last = last
        self.pay = pay
        self.email = first + "." + last + "@email.com"

    @classmethod  # cls - Ссылается на класс / self - ссылка на конкретный элемент класса (Объект)
    def from_string(cls, emp_str):  # cls - ссылка на класс
        first, last, pay = emp_str.split('-')
        return cls(first, last, pay)



    @classmethod
    def set_raise_amt(cls, new_raise_amt):
        """Передаем объект и меняем значение атрибута класса (с 1.04 на 1.05)"""
        cls.raise_amt = new_raise_amt



    @staticmethod               # статический метод применяется тех случаях: когда нам не нужно обращаться ни к классу ни к его атрибутам, но данный функционал может каким либо образом работать с классом
    def is_workday(date):       #значит нам нужно на вход принимать только саму дату
        """Статический метод"""
        if date.weekday == 5 or date.weekday == 6:
            return True
        return False






# проверка

# =================== 1 Задача ====================
# Получили строки с именем сотрудника и зарплатой

# emp_str_1 = "Jon-Snow-70000"
# emp_str_2 = "Ivan-Ivanov-30000"
# emp_str_3 = "Elena-Nikitina-90000"
#
# new_emp_1 = Employee.from_string(emp_str_1)
"""Применяем к строке с данными сотрудника Метод класса from_string, который внутри своего функционала разбивает строку на елементы класса"""

# print(new_emp_1.email)    # и дальше ссылаясь на элементы объекта получаем нужные значения
# print(new_emp_1.pay)


# Так данные записываются без функции @classmethod
# first, last, pay = emp_str_1.split('-')   # Необходимо разбить данную строку по - знаку и передаем это в аргументы класса
# new_emp_1 = Employee(first, last, pay)
# print(new_emp_1.email)  # и тут при обращении к классу мы получаем на выход email
# print(new_emp_1.pay)    # и его зп отдельно
# ======================================================

# =========================== 2 Задача =======================

emp_1 = Employee("Jon", "Snow", 50000)
emp_2 = Employee("Ivan", "Ivanov", 60000)

print(emp_1.raise_amt)  # значение 1.04

"""тут мы обращаемся к функции класса, что бы поменять значение переменной атрибута Класса (raise_amt = 1.04)"""
Employee.set_raise_amt(1.05)

print(Employee.raise_amt)
print(emp_1.raise_amt)  # значение 1.05
print(emp_2.raise_amt)  # значение 1.05


# =========================== 3 Задача =======================

"""
В данном примере нам не нужна ссылка на класс, так как нам не нужно обращаться к самому объекту, не обащаемся к классу
мы обращаемся только к тем аргументам которые передаются
таким образом мы делаем вывод что нам нужен @staticmethod

"""
my_date = datetime.date(2024, 8, 3)
print(Employee.is_workday(my_date))
